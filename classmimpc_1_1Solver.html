<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIMPC++: mimpc::Solver&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MIMPC++
   </div>
   <div id="projectbrief">A fast typesafe Mixed Integer MPC C++ library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mimpc</b></li><li class="navelem"><a class="el" href="classmimpc_1_1Solver.html">Solver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classmimpc_1_1Solver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mimpc::Solver&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Solver_8hpp_source.html">Solver.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mimpc::Solver&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classmimpc_1_1Solver__inherit__graph.png" border="0" usemap="#amimpc_1_1Solver_3_01SystemType_00_01N_00_01min__steps__on_00_01min__steps__off_00_01max__steps__on_00_01num__steps__solver__delay_00_01integration__scheme_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="amimpc_1_1Solver_3_01SystemType_00_01N_00_01min__steps__on_00_01min__steps__off_00_01max__steps__on_00_01num__steps__solver__delay_00_01integration__scheme_01_4_inherit__map" id="amimpc_1_1Solver_3_01SystemType_00_01N_00_01min__steps__on_00_01min__steps__off_00_01max__steps__on_00_01num__steps__solver__delay_00_01integration__scheme_01_4_inherit__map">
<area shape="rect" title=" " alt="" coords="5,20,269,91"/>
<area shape="rect" href="classmimpc_1_1SCIPSolver.html" title=" " alt="" coords="317,5,551,105"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae06746be62dac51e14418e8cdec2a768"><td class="memItemLeft" align="right" valign="top"><a id="ae06746be62dac51e14418e8cdec2a768"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SYSTEM_TYPE</b> = SystemType</td></tr>
<tr class="separator:ae06746be62dac51e14418e8cdec2a768"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a07f26e76b0e6d06c1febf24650eb9353"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmimpc_1_1Solver.html#a07f26e76b0e6d06c1febf24650eb9353">addInputConstraintOnIndex</a> (int index, double lb, double ub)=0</td></tr>
<tr class="separator:a07f26e76b0e6d06c1febf24650eb9353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada42af55792445d859ec55d44d1db6c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmimpc_1_1Solver.html#aada42af55792445d859ec55d44d1db6c">addStateConstraintOnIndex</a> (int index, double lb, double ub)=0</td></tr>
<tr class="separator:aada42af55792445d859ec55d44d1db6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed2b1607217cf74d260b5383e5e204a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmimpc_1_1Solver.html#a0ed2b1607217cf74d260b5383e5e204a">addInputConstraintOnStep</a> (int step, const SystemType::InputVec &amp;lb, const SystemType::InputVec &amp;ub)=0</td></tr>
<tr class="separator:a0ed2b1607217cf74d260b5383e5e204a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cc368b2574fa8deb44b1319a469551"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmimpc_1_1Solver.html#a21cc368b2574fa8deb44b1319a469551">addStateConstraintOnStep</a> (int step, const SystemType::StateVec &amp;lb, const SystemType::StateVec &amp;ub)=0</td></tr>
<tr class="separator:a21cc368b2574fa8deb44b1319a469551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96def2d0d14f9a35bd4317d1253a35ec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmimpc_1_1Solver.html#a96def2d0d14f9a35bd4317d1253a35ec">setFinalWeights</a> (const SystemType::StateVec &amp;final_weights)=0</td></tr>
<tr class="separator:a96def2d0d14f9a35bd4317d1253a35ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6336046c972ea148dfa02e5746f6cd22"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmimpc_1_1Solver.html#a6336046c972ea148dfa02e5746f6cd22">setStateWeights</a> (const SystemType::StateVec &amp;state_weights)=0</td></tr>
<tr class="separator:a6336046c972ea148dfa02e5746f6cd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c4ae84ecd358839d039ebd09f6cca8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmimpc_1_1Solver.html#a61c4ae84ecd358839d039ebd09f6cca8">setInputWeights</a> (const SystemType::InputVec &amp;state_weights)=0</td></tr>
<tr class="separator:a61c4ae84ecd358839d039ebd09f6cca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd91779b58e0201fc46520678fac3326"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmimpc_1_1Solver.html#abd91779b58e0201fc46520678fac3326">setCost</a> (<a class="el" href="Solver_8hpp.html#a757f7bfa05ad32c34d8f69e7861806e5">COST_TYPE</a> cost_type)=0</td></tr>
<tr class="separator:abd91779b58e0201fc46520678fac3326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ad746dfcb72fd351231998fd903e05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmimpc_1_1Solver.html#af2ad746dfcb72fd351231998fd903e05">setSetPoint</a> (const SystemType::StateVec &amp;set_point)=0</td></tr>
<tr class="separator:af2ad746dfcb72fd351231998fd903e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34435622c0b5a1dfc9615f3f9852f1bd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmimpc_1_1Solver.html#a34435622c0b5a1dfc9615f3f9852f1bd">setState</a> (const SystemType::StateVec &amp;state)=0</td></tr>
<tr class="separator:a34435622c0b5a1dfc9615f3f9852f1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe701e06933a7e7fe190d5cf99ff8225"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmimpc_1_1Solver.html#afe701e06933a7e7fe190d5cf99ff8225">setInputHistory</a> (const Eigen::Matrix&lt; double, SystemType::NUM_INPUTS, <a class="el" href="classmimpc_1_1Solver.html#a0fe7838161467c745697cfa56923a37a">history_depth</a> &gt; &amp;bin_input_hist)=0</td></tr>
<tr class="separator:afe701e06933a7e7fe190d5cf99ff8225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb9eb399325c4e0549125b55ab7d062"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmimpc_1_1Solver.html#aefb9eb399325c4e0549125b55ab7d062">setNextInputs</a> (const Eigen::Matrix&lt; double, SystemType::NUM_INPUTS, num_steps_solver_delay &gt; &amp;next_inputs)=0</td></tr>
<tr class="separator:aefb9eb399325c4e0549125b55ab7d062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddf3054660be361436992f930461f46"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmimpc_1_1Solver.html#aeddf3054660be361436992f930461f46">setSolverTimeLimit</a> (double max_seconds)=0</td></tr>
<tr class="separator:aeddf3054660be361436992f930461f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0939f3a743777b060af28981bce161"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmimpc_1_1Solver.html#a5a0939f3a743777b060af28981bce161">getStepsToCompensateControllerDelay</a> ()=0</td></tr>
<tr class="separator:a5a0939f3a743777b060af28981bce161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe3aa87885c74b6216e771345f69e5a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="Solver_8hpp.html#a383cda20e6b30b64cccaac7a84042133">SOLVER_RETURN</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmimpc_1_1Solver.html#adbe3aa87885c74b6216e771345f69e5a">solve</a> (const Eigen::Matrix&lt; double, SystemType::NUM_INPUTS, N, Eigen::RowMajor &gt; &amp;last_open_loop_input, const Eigen::Matrix&lt; double, SystemType::NUM_STATES, N+1, Eigen::RowMajor &gt; &amp;last_open_loop_state, Eigen::Matrix&lt; double, SystemType::NUM_INPUTS, N, Eigen::RowMajor &gt; &amp;open_loop_input, Eigen::Matrix&lt; double, SystemType::NUM_STATES, N+1, Eigen::RowMajor &gt; &amp;open_loop_state) const =0</td></tr>
<tr class="separator:adbe3aa87885c74b6216e771345f69e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a46fdf123b725b80ce6041163aa7cb40e"><td class="memItemLeft" align="right" valign="top"><a id="a46fdf123b725b80ce6041163aa7cb40e"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>PRED_STEPS</b> = N</td></tr>
<tr class="separator:a46fdf123b725b80ce6041163aa7cb40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a852c19d937d2b00496b2c494cdfdf1"><td class="memItemLeft" align="right" valign="top"><a id="a4a852c19d937d2b00496b2c494cdfdf1"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MIN_STEPS_ON</b> = min_steps_on</td></tr>
<tr class="separator:a4a852c19d937d2b00496b2c494cdfdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef63e48465c5273a9f210f02d0edea6"><td class="memItemLeft" align="right" valign="top"><a id="aeef63e48465c5273a9f210f02d0edea6"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MIN_STEPS_OFF</b> = min_steps_off</td></tr>
<tr class="separator:aeef63e48465c5273a9f210f02d0edea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2789c00a83552b473117d6e1db1c99"><td class="memItemLeft" align="right" valign="top"><a id="a4d2789c00a83552b473117d6e1db1c99"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_STEPS_ON</b> = max_steps_on</td></tr>
<tr class="separator:a4d2789c00a83552b473117d6e1db1c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38e2fcbb7090ae9bd17217172d3dd0c"><td class="memItemLeft" align="right" valign="top"><a id="ab38e2fcbb7090ae9bd17217172d3dd0c"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>NUM_STEPS_SOLVER_DELAY</b> = num_steps_solver_delay</td></tr>
<tr class="separator:ab38e2fcbb7090ae9bd17217172d3dd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf4691a3fda2bca3688c00dc6817a95"><td class="memItemLeft" align="right" valign="top"><a id="a7cf4691a3fda2bca3688c00dc6817a95"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>INTEGRATION_SCHEME</b> = integration_scheme</td></tr>
<tr class="separator:a7cf4691a3fda2bca3688c00dc6817a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe7838161467c745697cfa56923a37a"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmimpc_1_1Solver.html#a0fe7838161467c745697cfa56923a37a">history_depth</a></td></tr>
<tr class="separator:a0fe7838161467c745697cfa56923a37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class SystemType, int N, int min_steps_on, int min_steps_off, int max_steps_on, int num_steps_solver_delay, INTEGRATION_SCHEME integration_scheme&gt;<br />
class mimpc::Solver&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;</h3>

<p>This defines abstract base class defines a wrapper around any mixed integer solver and defines a low level solver interface to be used within an mpc. For a highlevel interface refer to <a class="el" href="classmimpc_1_1MPC.html">MPC</a>, which takes any <a class="el" href="classmimpc_1_1Solver.html">Solver</a> implementation as a template argument.</p>
<p>The solver discretizes the time into time steps of same length.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SystemType</td><td>refers to the system dynamics and must be a class implementing <a class="el" href="classmimpc_1_1System.html">System</a> </td></tr>
    <tr><td class="paramname">N</td><td>prediction horizon </td></tr>
    <tr><td class="paramname">min_steps_on</td><td>number of discrete time steps that the binary inputs have to stay on </td></tr>
    <tr><td class="paramname">min_steps_off</td><td>number of discrete time steps that the binary inputs have to stay off </td></tr>
    <tr><td class="paramname">max_steps_on</td><td>maximum number of discrete time steps that the binary inputs can stay on </td></tr>
    <tr><td class="paramname">num_steps_solver_delay</td><td>number of discrete time steps that are solver delay, referring to the time delay from the time point system is at a current state (which will be set by <a class="el" href="classmimpc_1_1Solver.html#a34435622c0b5a1dfc9615f3f9852f1bd">setState()</a>) and the time point at which the optimal input returned by <a class="el" href="classmimpc_1_1Solver.html#adbe3aa87885c74b6216e771345f69e5a">solve()</a> is applied to the system. This delay is compensated by predicting the systems state based on the inputs that will be applied during this delay time. This inputs are set via <a class="el" href="classmimpc_1_1Solver.html#aefb9eb399325c4e0549125b55ab7d062">setNextInputs()</a> and can be for example taken from the previous open loop prediction. Obviously, the optimal input predicted by the solver and returned by <a class="el" href="classmimpc_1_1Solver.html#adbe3aa87885c74b6216e771345f69e5a">solve()</a> is the one at num_steps_solver_delay in the next open loop prediction, as the first refer to the predicted states during the delay. The correct index for the next input can be aquired using <a class="el" href="classmimpc_1_1Solver.html#a5a0939f3a743777b060af28981bce161">getStepsToCompensateControllerDelay()</a>. </td></tr>
    <tr><td class="paramname">integration_scheme</td><td>discretization method </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a07f26e76b0e6d06c1febf24650eb9353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f26e76b0e6d06c1febf24650eb9353">&#9670;&nbsp;</a></span>addInputConstraintOnIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SystemType , int N, int min_steps_on, int min_steps_off, int max_steps_on, int num_steps_solver_delay, INTEGRATION_SCHEME integration_scheme&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classmimpc_1_1Solver.html">mimpc::Solver</a>&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;::addInputConstraintOnIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds or replaces the bounding box constraint to the input variable with given index to all discrete time steps.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the respective input variable in the input vector </td></tr>
    <tr><td class="paramname">lb</td><td>lower bound </td></tr>
    <tr><td class="paramname">ub</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmimpc_1_1SCIPSolver.html#a7ed4245e2c7729e3078458ea0899146e">mimpc::SCIPSolver&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;</a>.</p>

</div>
</div>
<a id="a0ed2b1607217cf74d260b5383e5e204a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed2b1607217cf74d260b5383e5e204a">&#9670;&nbsp;</a></span>addInputConstraintOnStep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SystemType , int N, int min_steps_on, int min_steps_off, int max_steps_on, int num_steps_solver_delay, INTEGRATION_SCHEME integration_scheme&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classmimpc_1_1Solver.html">mimpc::Solver</a>&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;::addInputConstraintOnStep </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SystemType::InputVec &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SystemType::InputVec &amp;&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds or replaces the bounding box constraint to the input vector at given time step</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">step</td><td>time step 0&lt;=step&lt;=N </td></tr>
    <tr><td class="paramname">lb</td><td>lower bound </td></tr>
    <tr><td class="paramname">ub</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aada42af55792445d859ec55d44d1db6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada42af55792445d859ec55d44d1db6c">&#9670;&nbsp;</a></span>addStateConstraintOnIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SystemType , int N, int min_steps_on, int min_steps_off, int max_steps_on, int num_steps_solver_delay, INTEGRATION_SCHEME integration_scheme&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classmimpc_1_1Solver.html">mimpc::Solver</a>&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;::addStateConstraintOnIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds or replaces the bounding box constraint to the state variable with given index to all discrete time steps.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the respective state variable in the state vector </td></tr>
    <tr><td class="paramname">lb</td><td>lower bound </td></tr>
    <tr><td class="paramname">ub</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmimpc_1_1SCIPSolver.html#a4d60d3a82be84b6d8629c35c88758397">mimpc::SCIPSolver&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;</a>.</p>

</div>
</div>
<a id="a21cc368b2574fa8deb44b1319a469551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21cc368b2574fa8deb44b1319a469551">&#9670;&nbsp;</a></span>addStateConstraintOnStep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SystemType , int N, int min_steps_on, int min_steps_off, int max_steps_on, int num_steps_solver_delay, INTEGRATION_SCHEME integration_scheme&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classmimpc_1_1Solver.html">mimpc::Solver</a>&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;::addStateConstraintOnStep </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SystemType::StateVec &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SystemType::StateVec &amp;&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds or replaces the bounding box constraint to the state vector at given time step</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">step</td><td>time step 0&lt;=step&lt;=N </td></tr>
    <tr><td class="paramname">lb</td><td>lower bound </td></tr>
    <tr><td class="paramname">ub</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a0939f3a743777b060af28981bce161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a0939f3a743777b060af28981bce161">&#9670;&nbsp;</a></span>getStepsToCompensateControllerDelay()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SystemType , int N, int min_steps_on, int min_steps_off, int max_steps_on, int num_steps_solver_delay, INTEGRATION_SCHEME integration_scheme&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int <a class="el" href="classmimpc_1_1Solver.html">mimpc::Solver</a>&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;::getStepsToCompensateControllerDelay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the index at which the next input calculated by <a class="el" href="classmimpc_1_1Solver.html#adbe3aa87885c74b6216e771345f69e5a">solve()</a> has to be taken, in order to correct respect the solver delay compensation. Most of the times this value should refer to #num_steps_solver_delay </p><dl class="section return"><dt>Returns</dt><dd>num_steps_solver_delay </dd></dl>

<p>Implemented in <a class="el" href="classmimpc_1_1SCIPSolver.html#a589472fe1996c829d1bba973875af5be">mimpc::SCIPSolver&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;</a>.</p>

</div>
</div>
<a id="abd91779b58e0201fc46520678fac3326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd91779b58e0201fc46520678fac3326">&#9670;&nbsp;</a></span>setCost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SystemType , int N, int min_steps_on, int min_steps_off, int max_steps_on, int num_steps_solver_delay, INTEGRATION_SCHEME integration_scheme&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classmimpc_1_1Solver.html">mimpc::Solver</a>&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;::setCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Solver_8hpp.html#a757f7bfa05ad32c34d8f69e7861806e5">COST_TYPE</a>&#160;</td>
          <td class="paramname"><em>cost_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the error function type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cost_type</td><td>error function type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96def2d0d14f9a35bd4317d1253a35ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96def2d0d14f9a35bd4317d1253a35ec">&#9670;&nbsp;</a></span>setFinalWeights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SystemType , int N, int min_steps_on, int min_steps_off, int max_steps_on, int num_steps_solver_delay, INTEGRATION_SCHEME integration_scheme&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classmimpc_1_1Solver.html">mimpc::Solver</a>&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;::setFinalWeights </td>
          <td>(</td>
          <td class="paramtype">const SystemType::StateVec &amp;&#160;</td>
          <td class="paramname"><em>final_weights</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the state error weights of the final predicted state</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">final_weights</td><td>weight vector where each vector element refers to the respective state vector element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe701e06933a7e7fe190d5cf99ff8225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe701e06933a7e7fe190d5cf99ff8225">&#9670;&nbsp;</a></span>setInputHistory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SystemType , int N, int min_steps_on, int min_steps_off, int max_steps_on, int num_steps_solver_delay, INTEGRATION_SCHEME integration_scheme&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classmimpc_1_1Solver.html">mimpc::Solver</a>&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;::setInputHistory </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, SystemType::NUM_INPUTS, <a class="el" href="classmimpc_1_1Solver.html#a0fe7838161467c745697cfa56923a37a">history_depth</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bin_input_hist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the input history of past inputs. This is necessary in order to respect the timing constraints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bin_input_hist</td><td>input history matrix, where the first index refers to the input vector element and the second index to the history time step. Thereby index 0 refers to the most past element, and index <a class="el" href="classmimpc_1_1Solver.html#a0fe7838161467c745697cfa56923a37a">history_depth</a> refers to the current time step. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61c4ae84ecd358839d039ebd09f6cca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c4ae84ecd358839d039ebd09f6cca8">&#9670;&nbsp;</a></span>setInputWeights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SystemType , int N, int min_steps_on, int min_steps_off, int max_steps_on, int num_steps_solver_delay, INTEGRATION_SCHEME integration_scheme&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classmimpc_1_1Solver.html">mimpc::Solver</a>&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;::setInputWeights </td>
          <td>(</td>
          <td class="paramtype">const SystemType::InputVec &amp;&#160;</td>
          <td class="paramname"><em>state_weights</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the input weights of all intermediate predicted inputs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state_weights</td><td>weight vector where each vector element refers to the respective input vector element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefb9eb399325c4e0549125b55ab7d062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb9eb399325c4e0549125b55ab7d062">&#9670;&nbsp;</a></span>setNextInputs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SystemType , int N, int min_steps_on, int min_steps_off, int max_steps_on, int num_steps_solver_delay, INTEGRATION_SCHEME integration_scheme&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classmimpc_1_1Solver.html">mimpc::Solver</a>&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;::setNextInputs </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, SystemType::NUM_INPUTS, num_steps_solver_delay &gt; &amp;&#160;</td>
          <td class="paramname"><em>next_inputs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the inputs that the will be applied to the system during the solver delay, in order to predicts the systems behaviour while the solver optimizes the next input</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_inputs</td><td>input sequence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2ad746dfcb72fd351231998fd903e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ad746dfcb72fd351231998fd903e05">&#9670;&nbsp;</a></span>setSetPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SystemType , int N, int min_steps_on, int min_steps_off, int max_steps_on, int num_steps_solver_delay, INTEGRATION_SCHEME integration_scheme&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classmimpc_1_1Solver.html">mimpc::Solver</a>&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;::setSetPoint </td>
          <td>(</td>
          <td class="paramtype">const SystemType::StateVec &amp;&#160;</td>
          <td class="paramname"><em>set_point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the state set point. The state error is then calculated by applying the error function (as defined by setCost) to the difference between the current or predicted state and the set point. Each state error vector element is weighted by the state and final weights as specified by setStateWeights and setFinalWeights</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set_point</td><td>the state set point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeddf3054660be361436992f930461f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeddf3054660be361436992f930461f46">&#9670;&nbsp;</a></span>setSolverTimeLimit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SystemType , int N, int min_steps_on, int min_steps_off, int max_steps_on, int num_steps_solver_delay, INTEGRATION_SCHEME integration_scheme&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classmimpc_1_1Solver.html">mimpc::Solver</a>&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;::setSolverTimeLimit </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the maximum time that the solver will try to find the optimal solution when solve is called. If the maximum time is reached, the best solution found so far will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_seconds</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmimpc_1_1SCIPSolver.html#a43e49c124aa56ff5bf0307674e5a25d7">mimpc::SCIPSolver&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;</a>.</p>

</div>
</div>
<a id="a34435622c0b5a1dfc9615f3f9852f1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34435622c0b5a1dfc9615f3f9852f1bd">&#9670;&nbsp;</a></span>setState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SystemType , int N, int min_steps_on, int min_steps_off, int max_steps_on, int num_steps_solver_delay, INTEGRATION_SCHEME integration_scheme&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classmimpc_1_1Solver.html">mimpc::Solver</a>&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;::setState </td>
          <td>(</td>
          <td class="paramtype">const SystemType::StateVec &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the current system state which is then used to do the optimization and prediction process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>system state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6336046c972ea148dfa02e5746f6cd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6336046c972ea148dfa02e5746f6cd22">&#9670;&nbsp;</a></span>setStateWeights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SystemType , int N, int min_steps_on, int min_steps_off, int max_steps_on, int num_steps_solver_delay, INTEGRATION_SCHEME integration_scheme&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classmimpc_1_1Solver.html">mimpc::Solver</a>&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;::setStateWeights </td>
          <td>(</td>
          <td class="paramtype">const SystemType::StateVec &amp;&#160;</td>
          <td class="paramname"><em>state_weights</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the state error weights of all intermediate predicted states</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state_weights</td><td>weight vector where each vector element refers to the respective state vector element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbe3aa87885c74b6216e771345f69e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe3aa87885c74b6216e771345f69e5a">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SystemType , int N, int min_steps_on, int min_steps_off, int max_steps_on, int num_steps_solver_delay, INTEGRATION_SCHEME integration_scheme&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="Solver_8hpp.html#a383cda20e6b30b64cccaac7a84042133">SOLVER_RETURN</a> <a class="el" href="classmimpc_1_1Solver.html">mimpc::Solver</a>&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;::solve </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, SystemType::NUM_INPUTS, N, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>last_open_loop_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, SystemType::NUM_STATES, N+1, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>last_open_loop_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, SystemType::NUM_INPUTS, N, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>open_loop_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, SystemType::NUM_STATES, N+1, Eigen::RowMajor &gt; &amp;&#160;</td>
          <td class="paramname"><em>open_loop_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Starts the solving process in order to find the optimal input and state sequence. Given the cost function and constraints. If a time limit as been set with setSolverTimeLimit, the method will return after that time with no or the best solution found so far.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">last_open_loop_input</td><td>an optimal open loop input sequence (i.e. from last iteration) that is used to warm start the solver </td></tr>
    <tr><td class="paramname">last_open_loop_state</td><td>an optimal open loop state sequence (i.e. from last iteration) that is used to warm start the solver </td></tr>
    <tr><td class="paramname">open_loop_input</td><td>the optimal/suboptimal input sequence found by the solver, depending on the delay compensation the next input is at discrete time step <a class="el" href="classmimpc_1_1Solver.html#a5a0939f3a743777b060af28981bce161">getStepsToCompensateControllerDelay()</a> </td></tr>
    <tr><td class="paramname">open_loop_state</td><td>the optimal/suboptimal state sequence found by the solver </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return state indicates if the solution is optimal, suboptimal or no solution was found </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0fe7838161467c745697cfa56923a37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe7838161467c745697cfa56923a37a">&#9670;&nbsp;</a></span>history_depth</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SystemType , int N, int min_steps_on, int min_steps_off, int max_steps_on, int num_steps_solver_delay, INTEGRATION_SCHEME integration_scheme&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classmimpc_1_1Solver.html">mimpc::Solver</a>&lt; SystemType, N, min_steps_on, min_steps_off, max_steps_on, num_steps_solver_delay, integration_scheme &gt;::history_depth</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= std::max(</div>
<div class="line">                {0, max_steps_on - num_steps_solver_delay, min_steps_off - num_steps_solver_delay,</div>
<div class="line">                 min_steps_on - num_steps_solver_delay})</div>
</div><!-- fragment --><p>Gives, based on the timing constraints the number of past discrete time steps that the optimization problem needs to know </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="Solver_8hpp_source.html">Solver.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
